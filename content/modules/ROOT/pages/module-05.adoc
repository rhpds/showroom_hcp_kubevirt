= Storage

== Hosted Cluster storage

Using the UI create a PVC inside of the guest cluster (Ensure you are in the cluster `cluster1`)

. Navigate to *Storage* -> *PersistentVolumeClaims*
+
image::_images/Storage/01_PVC_Menu.png[]

. Press `Create PersistentVolumeClaim` on the top-right 

. Fill with the name `pvc01` and the size `1 GiB`
+
image::_images/Storage/02_PVC_Create.png[]


. Automatically the _PVC_ will be on *Bound* status
+
image::_images/Storage/03_PVC_Bound.png[]

. Now in the main cluster, navigate to *Storage* -> *PersistentVolumeClaims* and select project `clusters-cluster1`. Sort by Capacity
+
image::_images/Storage/04_PVC_Created.png[]


== Etcd storage

Because _etcd_ writes data to disk and persists proposals on disk, its performance depends on disk performance. Although _etcd_ is not particularly I/O intensive, it requires a low latency block device for optimal performance and stability.

* In terms of latency, run etcd on top of a block device that can write at least 50 IOPS of 8000 bytes long sequentially.
* That is, with a latency of 10ms, keep in mind that uses fdatasync to synchronize each write in the WAL. 
* For heavy loaded clusters, sequential 500 IOPS of 8000 bytes (2 ms) are recommended. 
* To achieve such performance, run etcd on machines that are backed by SSD or NVMe disks with low latency and high throughput. 

Review the current etcd _PVCs_ for the `cluster1`

image::_images/Storage/05_PVC_Etcd.png[]

Later in this lab a new cluster is created using local disks for _etcd_.

== OpenShift Virtualization image caching

By default a CoreOS image is downloaded for each of the workers, which will cause more storage used and more overload to import the image.

_Image caching_ is an advanced feature that you can use to optimize both cluster startup time and storage utilization. 
[NOTE]
This feature requires the use of a storage class that is capable of smart cloning and the ReadWriteMany access mode.

Image caching works as follows:

* The VM image is imported to a PVC that is associated with the hosted cluster.
* A unique clone of that PVC is created for every KubeVirt VM that is added as a worker node to the cluster.

Image caching reduces VM startup time by requiring only a single image import. It can further reduce overall cluster storage usage when the storage class supports copy-on-write cloning.

== Destroy current cluster 

. Delete the _managed cluster_ resource on multicluster engine operator by running the following command:
+
[source,bash,role=execute]
----
oc delete managedcluster cluster1
----
+
.Sample Output
+
[%nowrap]
----
managedcluster.cluster.open-cluster-management.io "cluster1" deleted
----

. Delete the _hosted cluster_ and its back-end resources by running the following command
+
[source,bash,role=execute]
----
hcp destroy cluster kubevirt --name cluster1
----
+
.Sample Output
+
[%nowrap]
----
2024-01-02T21:09:35Z    INFO    Found hosted cluster    {"namespace": "clusters", "name": "cluster1"}
2024-01-02T21:09:36Z    INFO    Updated finalizer for hosted cluster    {"namespace": "clusters", "name": "cluster1"}
2024-01-02T21:09:36Z    INFO    Deleting hosted cluster {"namespace": "clusters", "name": "cluster1"}
2024-01-02T21:11:24Z    INFO    Deleting Secrets        {"namespace": "clusters"}
2024-01-02T21:11:24Z    INFO    Deleted CLI generated secrets
2024-01-02T21:11:24Z    INFO    Finalized hosted cluster        {"namespace": "clusters", "name": "cluster1"}
2024-01-02T21:11:24Z    INFO    Successfully destroyed cluster and infrastructure       {"namespace": "clusters", "name": "cluster1", "infraID": "cluster1-qwpqk"}
----

